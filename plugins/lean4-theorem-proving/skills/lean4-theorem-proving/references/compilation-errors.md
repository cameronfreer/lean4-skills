# Common Compilation Errors in Lean 4

This reference provides detailed explanations and fixes for the most common compilation errors encountered in Lean 4 theorem proving.

## Quick Reference Table

| Error | Cause | Fix |
|-------|-------|-----|
| **"failed to synthesize instance"** | Missing type class | Add `haveI : IsProbabilityMeasure Œº := ‚ü®proof‚ü©` |
| **"maximum recursion depth"** | Type class loop/complex search | Provide manually: `letI := instance` or increase: `set_option synthInstance.maxHeartbeats 40000` |
| **"type mismatch"** (has type ‚Ñï but expected ‚Ñù) | Wrong type | Use coercion: `(x : ‚Ñù)` or `‚Üëx` |
| **"tactic 'exact' failed"** | Goal/term type mismatch | Use `apply` for unification or restructure: `‚ü®h.2, h.1‚ü©` |
| **"unknown identifier"** | Missing import OR unqualified name | Import tactic OR qualify: `Filter.Tendsto` |
| **"unexpected token/identifier"** | Section comment in proof | Replace `/-! -/` with `--` in tactic mode |
| **"no goals to be solved"** | Tactic already finished | Remove redundant tactics after `simp` |
| **"equation compiler failed"** | Can't prove termination | Add `termination_by my_rec n => n` clause |

## Detailed Error Explanations

### 1. Failed to Synthesize Instance

**Full error message:**
```
failed to synthesize instance
  IsProbabilityMeasure Œº
```

**What it means:** Lean cannot automatically infer the required type class instance.

**Common scenarios:**
- Working with sub-œÉ-algebras: `m ‚â§ m‚ÇÄ` but Lean can't infer instances on `m`
- Trimmed measures: `Œº.trim hm` needs explicit `SigmaFinite` instance
- Conditional expectations requiring multiple measure properties

**Solutions:**

**Pattern 1: Explicit instance declaration**
```lean
haveI : IsProbabilityMeasure Œº := ‚ü®measure_univ‚ü©
haveI : IsFiniteMeasure Œº := inferInstance
haveI : SigmaFinite (Œº.trim hm) := sigmaFinite_trim Œº hm
```

**Pattern 2: Using Fact for inequalities**
```lean
have h_le : m ‚â§ m‚ÇÄ := ...
haveI : Fact (m ‚â§ m‚ÇÄ) := ‚ü®h_le‚ü©
```

**Pattern 3: Explicit instance passing**
```lean
@condExp Œ© ‚Ñù m‚ÇÄ m (by exact inst) Œº (by exact hm) f
```

**Pattern 4: Exclude unwanted section variables**
```lean
-- When section has `variable [MeasurableSpace Œ©]` but lemma doesn't need it
omit [MeasurableSpace Œ©] in
/-- Docstring for the lemma -/
lemma my_lemma : Statement := by
  proof
```
- **Must appear before the docstring** (not after)
- Common when section variables cause unwanted instance requirements
- Can omit multiple: `omit [inst1] [inst2] in`

**For deep patterns with sub-œÉ-algebras, conditional expectation, and measure theory type class issues, see:** `measure-theory.md`

**Debug with:**
```lean
set_option trace.Meta.synthInstance true in
theorem my_theorem : Goal := by
  apply_instance
```

### 2. Maximum Recursion Depth

**Full error message:**
```
(deterministic) timeout at 'typeclass', maximum number of heartbeats (20000) has been reached
```

**What it means:** Type class synthesis is stuck in a loop or the search is too complex.

**Common causes:**
- Circular instance dependencies
- Very deep instance search trees
- Ambiguous instances competing

**Solutions:**

**Solution 1: Provide instance manually**
```lean
letI : MeasurableSpace Œ© := m‚ÇÄ  -- Freeze the instance
-- Now Lean won't search
```

**Solution 2: Increase search limit**
```lean
set_option synthInstance.maxHeartbeats 40000 in
theorem my_theorem : Goal := ...
```

**Solution 3: Check for instance loops**
```lean
-- ‚ùå BAD: Creates loop
instance [Foo A] : Bar A := ...
instance [Bar A] : Foo A := ...

-- ‚úÖ GOOD: One-directional
instance [Foo A] : Bar A := ...
```

### 3. Type Mismatch

**Full error message:**
```
type mismatch
  x
has type
  ‚Ñï
but is expected to have type
  ‚Ñù
```

**What it means:** The term's type doesn't match what's expected.

**Common scenarios:**
- Natural number used where real number expected
- Integer used where rational expected
- General coercion needed

**Solutions:**

**Pattern 1: Explicit coercion**
```lean
-- Natural to real
(n : ‚Ñù)  -- Preferred
‚Üën       -- Alternative

-- Integer to real
(z : ‚Ñù)

-- Custom coercion
‚ü®x, hx‚ü© : {x : ‚Ñù // x > 0}
```

**Pattern 2: Check actual types**
```lean
#check x        -- See current type
#check (x : ‚Ñù)  -- Verify coercion works
```

**Pattern 3: Function application**
```lean
-- If f : ‚Ñù ‚Üí ‚Ñù and n : ‚Ñï
f ‚Üën    -- Apply after coercion
f (n : ‚Ñù)  -- Explicit
```

### 4. Tactic 'exact' Failed

**Full error message:**
```
tactic 'exact' failed, type mismatch
  term
has type
  A ‚Üí B
but is expected to have type
  ‚àÄ x, A x ‚Üí B x
```

**What it means:** The term's type is close but not exactly the goal type.

**Solutions:**

**Solution 1: Use apply instead**
```lean
-- exact doesn't work but apply might
apply my_lemma
-- Leaves subgoals to fill
```

**Solution 2: Restructure term**
```lean
-- Wrong order
exact ‚ü®h.1, h.2‚ü©  -- Type mismatch

-- Correct order
exact ‚ü®h.2, h.1‚ü©  -- Works
```

**Solution 3: Add intermediate steps**
```lean
-- Instead of: exact complex_term
have h1 := part1
have h2 := part2
exact ‚ü®h1, h2‚ü©
```

### 5. Unknown Identifier (Missing Tactic or Qualification)

**Full error message:**
```
unknown identifier 'ring'
unknown identifier 'Tendsto'
```

**What it means:** Tactic not imported OR identifier needs qualification.

**Cause 1: Missing tactic import**

**Common missing imports:**
```lean
import Mathlib.Tactic.Ring          -- ring, ring_nf
import Mathlib.Tactic.Linarith      -- linarith, nlinarith
import Mathlib.Tactic.FieldSimp     -- field_simp
import Mathlib.Tactic.Continuity    -- continuity
import Mathlib.Tactic.Measurability -- measurability
import Mathlib.Tactic.Positivity    -- positivity
```

**Quick fix:**
1. See error for tactic name
2. Add `import Mathlib.Tactic.TacticName`
3. Rebuild

**Cause 2: Bare identifier needs qualification**

Lean 4 requires fully qualified names where Lean 3 allowed bare names:

```lean
-- ‚ùå WRONG: Bare identifiers
have h : Tendsto f atTop (ùìù x) := ...

-- ‚úÖ CORRECT: Qualified names
have h : Filter.Tendsto f Filter.atTop (nhds x) := ...
```

**Common qualifications:**
- `Tendsto` ‚Üí `Filter.Tendsto`
- `atTop` ‚Üí `Filter.atTop`
- `ùìù x` ‚Üí `nhds x`
- `eventually` ‚Üí `Filter.Eventually`

### 6. Equation Compiler Failed (Termination)

**Full error message:**
```
fail to show termination for
  my_recursive_function
with errors
  ...
```

**What it means:** Lean can't automatically prove the function terminates.

**Solutions:**

**Pattern 1: Add termination_by clause**
```lean
def my_rec (n : ‚Ñï) : ‚Ñï :=
  if n = 0 then 0
  else my_rec (n - 1)
termination_by n  -- Decreasing argument
```

**Pattern 2: Well-founded recursion**
```lean
def my_rec (l : List Œ±) : Result :=
  match l with
  | [] => base_case
  | h :: t => combine h (my_rec t)
termination_by l.length
```

**Pattern 3: Use sorry for termination proof**
```lean
def my_rec (x : X) : Y := ...
termination_by measure_func x
decreasing_by sorry  -- TODO: Prove later
```

### 7. Unsolved Goals (Nat.pos_of_ne_zero and Arithmetic)

**Full error message:**
```
unsolved goals
h : m ‚â† 0
h2 : (4 : ‚Ñù) / Œµ ‚â§ ‚Üëm
‚ä¢ False
```

**What it means:** After introducing a contradiction hypothesis, the goal is `False` but the tactic can't derive the contradiction.

**Common scenario:** Proving `m > 0` from `m ‚â† 0` and some bound, but `norm_num` fails because the expressions are symbolic (not concrete numbers).

**Why norm_num fails:**
- `norm_num` works on **concrete numerical expressions** (like `2 + 2 = 4`)
- When you have symbolic variables like `4/Œµ`, `norm_num` can't evaluate them
- After `rw [h]` where `h : m = 0`, you get `4/Œµ ‚â§ 0`, but `norm_num` can't derive `False` from this

**Solution: Use simp to eliminate variables, then linarith**

```lean
-- ‚ùå WRONG: norm_num can't solve symbolic arithmetic
have hm_pos' : m > 0 := Nat.pos_of_ne_zero (by
  intro h
  rw [h] at h2  -- Now h2 : 4/Œµ ‚â§ 0
  norm_num at h2  -- FAILS: can't derive False because 4/Œµ is symbolic
  )
-- Error: unsolved goals ‚ä¢ False

-- ‚úÖ CORRECT: simp eliminates the variable, then linarith
have hm_pos' : m > 0 := Nat.pos_of_ne_zero (by
  intro h
  simp [h] at h2  -- Now h2 : 4/Œµ ‚â§ 0 AND we eliminated m entirely
  have : (4 : ‚Ñù) / Œµ > 0 := by positivity  -- Explicit positivity proof
  linarith)  -- Can now derive contradiction: 0 < 4/Œµ ‚â§ 0
```

**Key insight:**
- `norm_num` = numerical normalization (concrete numbers)
- `simp` = simplification (eliminates variables, unfolds definitions)
- `linarith` = linear arithmetic solver (works with inequalities and symbolic expressions)

**General pattern for contradiction proofs:**
1. `simp [hypothesis]` to eliminate the contradictory assumption
2. Establish any needed positivity facts with `positivity`
3. `linarith` to derive the contradiction from inequalities

**When to use each tactic:**
- `norm_num`: Concrete arithmetic (`2 + 2 = 4`, `7 < 10`)
- `simp`: Simplify using hypotheses and definitions
- `linarith`: Linear inequalities with variables (`a + b ‚â§ c`, `x > 0 ‚Üí x + 1 > 0`)
- `omega`: Integer linear arithmetic (Lean 4.13+, works on `‚Ñï` and `‚Ñ§`)

### 8. Unexpected Token/Identifier in Proof (Section Doc Comments)

**Full error message:**
```
unexpected identifier; expected command
unexpected token 'have'; expected command
```

**What it means:** Section doc comments `/-! ... -/` in tactic mode can terminate proof parsing.

**CRITICAL:** Section doc comments terminate proof context, causing everything after to be interpreted as top-level declarations.

```lean
-- ‚ùå WRONG: Section comments break proof
lemma my_proof := by
  classical
  set mW := ... with hmW

  /-! ### Step 0: documentation -/

  set œÜp := ... with hœÜp  -- ERROR: unexpected identifier
  have h := ...           -- ERROR: unexpected token 'have'

-- ‚úÖ CORRECT: Use regular comments
lemma my_proof := by
  classical
  set mW := ... with hmW
  -- Step 0: documentation
  set œÜp := ... with hœÜp  -- ‚úì Works
  have h := ...           -- ‚úì Works
```

**Best practice:** Use `--` for in-proof comments, reserve `/-! -/` for top-level documentation only.

### 9. Variable Shadowing in Lambda

**Full error message:**
```
type mismatch
  a
has type
  Set ‚Ñù‚â•0‚àû
but is expected to have type
  Œ±
```

**What it means:** Lambda variable shadows outer variable, causing type confusion.

```lean
-- ‚ùå WRONG: 'a' in lambda shadows outer 'a'
have h_sp_le : ‚àÄ n a, (sp n a) ‚â§ œÜp a := by
  intro n a
  have := SimpleFunc.iSup_eapprox_apply
    (fun a => ENNReal.ofReal (max (œÜ a) 0))  -- 'a' shadows!
    ... a  -- ERROR: which 'a'?

-- ‚úÖ CORRECT: Rename lambda variable or add type annotation
have h_sp_le : ‚àÄ n a, (sp n a) ‚â§ œÜp a := by
  intro n a
  have := SimpleFunc.iSup_eapprox_apply
    (fun (x : Œ±) => ENNReal.ofReal (max (œÜ x) 0))
    ... a  -- ‚úì Clear: outer 'a'
```

**Prevention:** Use different variable names in nested lambdas or add explicit type annotations.

### 10. No Goals After Tactic

**Full error message:**
```
no goals to be solved
```

**What it means:** Previous tactic already completed the proof, but another tactic remains.

```lean
-- ‚ùå WRONG: simp already solved goal
have hœÜp_nn : ‚àÄ a, 0 ‚â§ œÜp a := by
  intro a
  simp [œÜp]
  exact le_max_right _ _  -- ERROR: no goals left

-- ‚úÖ CORRECT: Remove redundant tactic
have hœÜp_nn : ‚àÄ a, 0 ‚â§ œÜp a := by
  intro a
  simp [œÜp]  -- ‚úì simp completes proof
```

**Debug:** Check goal state after each tactic. If "no goals" appears, proof is done.

## Quick Debug Workflow

When encountering any error:

1. **Read error location carefully** - Often points to exact issue
2. **Use #check** - Verify types of all terms involved
3. **Simplify** - Try to create minimal example that fails
4. **Search mathlib** - Error might be documented in lemma comments
5. **Ask Zulip** - Lean community is very helpful

### Quick Checklist for "Unexpected" Errors in Proofs

When facing "unexpected identifier/token" in long proofs:

1. ‚òê Search for `/-! ... -/` section comments ‚Üí replace with `--`
2. ‚òê Check for bare identifiers (`Tendsto`, `atTop`) ‚Üí add qualification (`Filter.Tendsto`)
3. ‚òê Look for lambda shadowing ‚Üí rename variables or add type annotations
4. ‚òê Check for "no goals" after `simp` ‚Üí remove redundant tactics
5. ‚òê For section variables + explicit params ‚Üí rely on section, use `(by infer_instance)`
6. ‚òê For sub-œÉ-algebra work ‚Üí ensure `hmW_le : mW ‚â§ _` proof exists

## Type Class Debugging Commands

```lean
-- See synthesis trace
set_option trace.Meta.synthInstance true in
theorem test : Goal := by apply_instance

-- See which instance was chosen
#check (inferInstance : IsProbabilityMeasure Œº)

-- Check all implicit arguments
#check @my_lemma
```

## Common Patterns to Avoid

### ‚ùå Fighting the Type Checker

```lean
-- Repeatedly trying variations until something compiles
exact h
exact h.1
exact ‚ü®h‚ü©
exact (h : _)  -- Guessing
```

### ‚úÖ Understanding Then Fixing

```lean
#check h  -- See what h actually is
#check goal  -- See what's needed
-- Now fix systematically
```

### ‚ùå Ignoring Error Messages

```lean
-- "It says type mismatch, let me try random things"
```

### ‚úÖ Reading Carefully

```lean
-- Error says "has type A but expected B"
-- Solution: Convert A to B or restructure
```
